<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gesture Draw 2D ¬∑ –ñ–µ—Å—Ç–æ–≤–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</title>
<style>
/* ===== GLOBAL VARIABLES ===== */
:root {
  --bg-deep: #0a0a0f;
  --glass-dark: rgba(18, 22, 30, 0.85);
  --glass-border: rgba(75, 227, 255, 0.15);
  --accent-primary: #4be3ff;
  --accent-secondary: #c084fc;
  --accent-glow: 0 0 20px rgba(75, 227, 255, 0.4);
  --text-light: rgba(255, 255, 255, 0.92);
  --text-soft: rgba(255, 255, 255, 0.7);
  --surface-elevated: rgba(28, 32, 42, 0.9);
  --surface-hover: rgba(48, 54, 70, 0.95);
  --shadow-xl: 0 20px 35px -8px rgba(0,0,0,0.6), 0 0 0 1px rgba(255,255,255,0.02);
  --transition-smooth: all 0.3s cubic-bezier(0.2, 0, 0, 1);
  --border-radius-lg: 28px;
  --border-radius-xl: 36px;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: var(--bg-deep);
  font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
  color: var(--text-light);
}

/* ===== CURSOR ‚Äî –î–í–ê –†–ï–ñ–ò–ú–ê ===== */
#pinchCursor {
  position: fixed;
  width: 36px;
  height: 36px;
  border-radius: 50%;
  background: radial-gradient(circle at 30% 30%, rgba(75, 227, 255, 0.95), rgba(0, 180, 255, 0.9));
  box-shadow: 0 0 30px rgba(75, 227, 255, 0.7), 0 0 60px rgba(75, 227, 255, 0.3),
              inset 0 0 0 2px rgba(255, 255, 255, 0.9);
  transform: translate(-50%, -50%) scale(1);
  pointer-events: none;
  z-index: 9999;
  transition: transform 0.18s cubic-bezier(0.34, 1.56, 0.64, 1), 
              background 0.25s ease,
              box-shadow 0.25s ease,
              width 0.2s ease,
              height 0.2s ease;
  backdrop-filter: blur(2px);
  border: 1px solid rgba(255,255,255,0.2);
}

#pinchCursor.active {
  transform: translate(-50%, -50%) scale(1.7);
  background: radial-gradient(circle at 30% 30%, #ff6b6b, #ff4757);
  box-shadow: 0 0 40px #ff6b6b, 0 0 90px #ff4757,
              inset 0 0 0 3px rgba(255,255,255,0.9);
  width: 32px;
  height: 32px;
}

/* –ö—É—Ä—Å–æ—Ä –≤ —Ä–µ–∂–∏–º–µ UI (–Ω–∞–≤–∏–≥–∞—Ü–∏—è) */
#pinchCursor.ui-mode {
  background: radial-gradient(circle at 30% 30%, #c084fc, #9f7aea);
  box-shadow: 0 0 40px #c084fc, 0 0 90px #9f7aea,
              inset 0 0 0 3px white;
  transform: translate(-50%, -50%) scale(1.4);
  width: 40px;
  height: 40px;
}

.cursor-fist {
  background: radial-gradient(circle at 30% 30%, #5ddcff, #3b9eff) !important;
  box-shadow: 0 0 60px #5ddcff, 0 0 120px #3b9eff,
              inset 0 0 0 4px white !important;
  transform: translate(-50%, -50%) scale(1.8) !important;
  width: 44px !important;
  height: 44px !important;
}

.cursor-eraser {
  background: radial-gradient(circle at 30% 30%, #ffffff, #e0e0e0) !important;
  box-shadow: 0 0 40px rgba(255,255,255,0.8), 0 0 80px rgba(255,255,255,0.4),
              inset 0 0 0 3px rgba(0,0,0,0.2) !important;
}

/* ===== VIDEO LAYER ===== */
#camera {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  object-fit: cover;
  z-index: 0;
  transform: scaleX(1);
  transition: opacity 0.5s ease, transform 0.4s ease;
  filter: brightness(0.9) contrast(1.15);
}

#camera.mirrored { transform: scaleX(-1); }
#camera.hidden { opacity: 0; visibility: hidden; }

/* ===== BG OVERLAY ===== */
#bgColorOverlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  z-index: 0;
  background: radial-gradient(circle at 50% 50%, #0b0b14, #050508);
  transition: opacity 0.5s ease;
  opacity: 0;
  pointer-events: none;
}
#bgColorOverlay.visible { opacity: 1; }

/* ===== CANVAS ===== */
#canvas {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  z-index: 5;
  cursor: none;
  pointer-events: none;
}

/* ===== TOGGLE BUTTON ===== */
#toggleSidebar {
  position: fixed;
  left: 24px;
  top: 24px;
  width: 56px;
  height: 56px;
  background: var(--surface-elevated);
  backdrop-filter: blur(16px);
  border: 1px solid var(--glass-border);
  border-radius: 24px;
  color: white;
  cursor: pointer;
  z-index: 1000;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: var(--transition-smooth);
  box-shadow: 0 10px 30px -10px rgba(0,0,0,0.5);
  font-size: 24px;
  border: 1px solid rgba(75, 227, 255, 0.2);
}

#toggleSidebar:hover {
  background: rgba(48, 58, 80, 0.9);
  border-color: var(--accent-primary);
  box-shadow: 0 0 30px rgba(75, 227, 255, 0.3);
  transform: scale(1.1) rotate(5deg);
}

/* ===== –û–°–ù–û–í–ù–û–ô –ö–û–ù–¢–ï–ô–ù–ï–† –ü–ê–ù–ï–õ–ï–ô ===== */
.panels-container {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 800;
}

/* ===== –ü–ê–ù–ï–õ–¨ –ò–ù–°–¢–†–£–ú–ï–ù–¢–û–í ===== */
#toolsPanel {
  position: fixed;
  left: 20px;
  top: 80px;
  width: 380px;
  background: var(--glass-dark);
  backdrop-filter: blur(20px) saturate(180%);
  border: 1px solid var(--glass-border);
  border-radius: 36px;
  z-index: 900;
  display: flex;
  flex-direction: column;
  padding: 32px 28px;
  gap: 32px;
  transform: translateX(-120%);
  transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1), 
              opacity 0.4s ease,
              box-shadow 0.3s;
  box-shadow: var(--shadow-xl);
  opacity: 0;
  pointer-events: none;
  border-right: none;
  max-height: calc(100vh - 100px);
  overflow-y: auto;
}

#toolsPanel.visible {
  transform: translateX(0);
  opacity: 1;
  pointer-events: auto;
}

/* ===== –ü–ê–ù–ï–õ–¨ –ù–ê–°–¢–†–û–ï–ö ===== */
#settingsPanel {
  position: fixed;
  left: 20px;
  top: 80px;
  width: 380px;
  background: var(--glass-dark);
  backdrop-filter: blur(20px) saturate(180%);
  border: 1px solid var(--glass-border);
  border-radius: 36px;
  z-index: 900;
  display: flex;
  flex-direction: column;
  padding: 32px 28px;
  gap: 32px;
  transform: translateX(-120%);
  transition: transform 0.5s cubic-bezier(0.16, 1, 0.3, 1), 
              opacity 0.4s ease,
              box-shadow 0.3s;
  box-shadow: var(--shadow-xl);
  opacity: 0;
  pointer-events: none;
  border-right: none;
  max-height: calc(100vh - 100px);
  overflow-y: auto;
}

#settingsPanel.visible {
  transform: translateX(0);
  opacity: 1;
  pointer-events: auto;
}

/* –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –∞–∫—Ç–∏–≤–Ω–æ–π –ø–∞–Ω–µ–ª–∏ */
.panel-indicator {
  position: absolute;
  top: -12px;
  left: 30px;
  background: var(--accent-primary);
  color: black;
  padding: 8px 20px;
  border-radius: 30px;
  font-size: 14px;
  font-weight: 700;
  letter-spacing: 1.5px;
  text-transform: uppercase;
  box-shadow: 0 0 20px var(--accent-primary);
  border: 1px solid rgba(255,255,255,0.5);
  white-space: nowrap;
}

/* ===== –°–ö–†–û–õ–õ –ü–ê–ù–ï–õ–ï–ô ===== */
#toolsPanel::-webkit-scrollbar,
#settingsPanel::-webkit-scrollbar {
  width: 5px;
}
#toolsPanel::-webkit-scrollbar-track,
#settingsPanel::-webkit-scrollbar-track {
  background: transparent;
  margin-block: 20px;
}
#toolsPanel::-webkit-scrollbar-thumb,
#settingsPanel::-webkit-scrollbar-thumb {
  background: rgba(93, 220, 255, 0.3);
  border-radius: 20px;
}
#toolsPanel::-webkit-scrollbar-thumb:hover,
#settingsPanel::-webkit-scrollbar-thumb:hover {
  background: rgba(93, 220, 255, 0.7);
}

/* ===== –°–ï–ö–¶–ò–ò ===== */
.section {
  display: flex;
  flex-direction: column;
  gap: 16px;
  animation: slideInSection 0.4s ease-out;
}

@keyframes slideInSection {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.section-title {
  font-size: 14px;
  font-weight: 600;
  letter-spacing: 1.5px;
  text-transform: uppercase;
  color: var(--accent-primary);
  padding-left: 6px;
  border-left: 3px solid var(--accent-primary);
  line-height: 1.2;
  text-shadow: 0 0 10px rgba(75,227,255,0.3);
}

/* ===== –ö–ù–û–ü–ö–ò ===== */
.button-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 12px;
}

.button-row {
  display: flex;
  gap: 12px;
}

.btn {
  background: var(--surface-elevated);
  border: 1px solid rgba(255,255,255,0.04);
  color: var(--text-soft);
  padding: 14px 12px;
  border-radius: 20px;
  cursor: pointer;
  transition: var(--transition-smooth);
  font-size: 14px;
  font-weight: 500;
  text-align: center;
  flex: 1;
  min-height: 52px;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  backdrop-filter: blur(5px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.2);
  position: relative;
  overflow: hidden;
}

.btn::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: radial-gradient(circle at 50% 50%, rgba(75,227,255,0.2), transparent 70%);
  opacity: 0;
  transition: opacity 0.3s;
}

.btn:hover::after {
  opacity: 1;
}

.btn:hover {
  background: var(--surface-hover);
  border-color: rgba(75, 227, 255, 0.5);
  transform: translateY(-4px);
  box-shadow: 0 16px 28px -8px rgba(0,0,0,0.5), 0 0 0 1px rgba(75,227,255,0.2);
  color: white;
}

.btn.active {
  background: linear-gradient(145deg, rgba(75,227,255,0.2), rgba(75,227,255,0.05));
  border-color: var(--accent-primary);
  color: var(--accent-primary);
  box-shadow: 0 0 25px rgba(75,227,255,0.3), inset 0 0 15px rgba(75,227,255,0.1);
}

.btn-icon {
  font-size: 20px;
  filter: drop-shadow(0 0 6px rgba(75,227,255,0.4));
}

/* ===== –¶–í–ï–¢–û–í–ê–Ø –ü–ê–õ–ò–¢–†–ê ===== */
.color-palette {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  margin-top: 8px;
}

.color-swatch {
  width: 48px;
  height: 48px;
  border-radius: 16px;
  cursor: pointer;
  border: 2px solid rgba(255,255,255,0.2);
  transition: var(--transition-smooth);
  position: relative;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  pointer-events: auto !important;
}

.color-swatch:hover {
  transform: scale(1.15);
  border-color: var(--accent-primary);
  box-shadow: 0 0 25px var(--accent-primary);
}

.color-swatch.active {
  border-color: var(--accent-primary);
  box-shadow: 0 0 30px var(--accent-primary);
  transform: scale(1.1);
}

.color-swatch.active::after {
  content: '‚úì';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
  font-size: 24px;
  text-shadow: 0 0 10px rgba(0,0,0,0.5);
  font-weight: bold;
}

/* ===== COLOR PICKER ===== */
.color-picker {
  width: 100%;
  height: 52px;
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 20px;
  overflow: hidden;
  cursor: pointer;
  background: var(--surface-elevated);
  padding: 4px;
  transition: var(--transition-smooth);
  box-shadow: inset 0 2px 8px rgba(0,0,0,0.4);
}

.color-picker:hover {
  border-color: var(--accent-primary);
  box-shadow: 0 0 20px rgba(75,227,255,0.3);
}

.color-picker::-webkit-color-swatch-wrapper { padding: 0; }
.color-picker::-webkit-color-swatch {
  border: none;
  border-radius: 16px;
  min-height: 44px;
}

/* ===== –°–õ–ê–ô–î–ï–†–´ ===== */
.slider-container {
  position: relative;
  margin-top: 6px;
}

.slider-label {
  display: flex;
  justify-content: space-between;
  margin-bottom: 10px;
  font-size: 13px;
  color: var(--text-soft);
  padding: 0 4px;
}

.slider-value {
  color: var(--accent-primary);
  font-weight: 700;
  background: rgba(75,227,255,0.15);
  padding: 4px 12px;
  border-radius: 30px;
  font-size: 12px;
  border: 1px solid rgba(75,227,255,0.3);
}

.slider {
  width: 100%;
  height: 8px;
  border-radius: 10px;
  background: rgba(30, 35, 48, 0.8);
  outline: none;
  -webkit-appearance: none;
  appearance: none;
  box-shadow: inset 0 1px 8px rgba(0,0,0,0.6);
  border: 1px solid rgba(255,255,255,0.05);
}

.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: radial-gradient(circle, var(--accent-primary), #1aabff);
  cursor: pointer;
  border: 2px solid white;
  box-shadow: 0 2px 15px var(--accent-primary);
  transition: var(--transition-smooth);
}

.slider::-webkit-slider-thumb:hover {
  transform: scale(1.25);
  box-shadow: 0 0 25px var(--accent-primary);
}

/* ===== –¢–û–ì–ì–õ ===== */
.toggle-group {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 12px 8px;
  background: rgba(0,0,0,0.2);
  border-radius: 40px;
  border: 1px solid rgba(255,255,255,0.05);
}

.toggle-label {
  font-size: 14px;
  font-weight: 500;
  color: var(--text-soft);
}

.toggle-btn {
  position: relative;
  width: 54px;
  height: 28px;
  background: rgba(40, 45, 60, 0.9);
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 34px;
  cursor: pointer;
  transition: var(--transition-smooth);
  box-shadow: inset 0 1px 5px rgba(0,0,0,0.5);
}

.toggle-btn::after {
  content: '';
  position: absolute;
  top: 2px;
  left: 2px;
  width: 22px;
  height: 22px;
  background: white;
  border-radius: 50%;
  transition: var(--transition-smooth);
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

.toggle-btn.active {
  background: var(--accent-primary);
  border-color: var(--accent-primary);
}

.toggle-btn.active::after {
  left: calc(100% - 24px);
  background: white;
  box-shadow: 0 0 15px white;
}

/* ===== –°–¢–ê–¢–£–° –ë–ê–† ===== */
#statusBar {
  position: fixed;
  bottom: 24px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(12, 16, 22, 0.7);
  backdrop-filter: blur(20px) saturate(200%);
  border: 1px solid rgba(75, 227, 255, 0.2);
  border-radius: 60px;
  padding: 12px 28px;
  color: white;
  font-size: 13px;
  z-index: 800;
  display: flex;
  align-items: center;
  gap: 28px;
  box-shadow: 0 15px 40px -10px black;
  letter-spacing: 0.5px;
}

.status-item {
  display: flex;
  align-items: center;
  gap: 10px;
}

.status-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: var(--accent-primary);
  box-shadow: 0 0 15px var(--accent-primary);
}

.status-dot.recording {
  animation: pulseGlow 1.8s infinite;
}

@keyframes pulseGlow {
  0%, 100% { opacity: 1; box-shadow: 0 0 15px var(--accent-primary); }
  50% { opacity: 0.6; box-shadow: 0 0 30px var(--accent-primary); }
}

/* ===== –ò–ù–î–ò–ö–ê–¢–û–†–´ ===== */
#modeIndicator {
  position: fixed;
  top: 90px;
  right: 24px;
  background: rgba(18, 25, 40, 0.8);
  backdrop-filter: blur(16px);
  padding: 12px 24px;
  border-radius: 40px;
  font-size: 14px;
  font-weight: 600;
  z-index: 1100;
  display: flex;
  align-items: center;
  gap: 12px;
  border: 1px solid var(--accent-primary);
  color: var(--accent-primary);
  box-shadow: 0 0 30px rgba(75,227,255,0.3);
}

.mode-icon {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: var(--accent-primary);
  box-shadow: 0 0 15px var(--accent-primary);
}

.mode-icon.drawing {
  background: #ff6b6b;
  box-shadow: 0 0 15px #ff6b6b;
}

.mode-text {
  letter-spacing: 1px;
}

#hoverIndicator {
  position: fixed;
  bottom: 100px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(75, 227, 255, 0.2);
  backdrop-filter: blur(20px);
  padding: 10px 24px;
  border-radius: 60px;
  font-size: 13px;
  font-weight: 600;
  z-index: 1100;
  display: none;
  border: 1px solid var(--accent-primary);
  color: white;
  box-shadow: 0 0 40px rgba(75,227,255,0.4);
  letter-spacing: 2px;
  white-space: nowrap;
}

/* ===== FEEDBACK RIPPLE ===== */
.feedback-ripple {
  position: fixed;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(75,227,255,0.7) 0%, transparent 70%);
  pointer-events: none;
  z-index: 10000;
  animation: clickFeedback 0.4s ease-out forwards;
}

@keyframes clickFeedback {
  0% { transform: translate(-50%, -50%) scale(0); opacity: 0.9; }
  100% { transform: translate(-50%, -50%) scale(3); opacity: 0; }
}

/* ===== UTILITY ===== */
.hidden { display: none !important; }
</style>
</head>
<body>

<!-- VIDEO LAYER -->
<video id="camera" autoplay muted playsinline></video>
<div id="bgColorOverlay"></div>

<!-- DRAWING CANVAS -->
<canvas id="canvas"></canvas>

<!-- GESTURE CURSOR -->
<div id="pinchCursor"></div>

<!-- –ò–ù–î–ò–ö–ê–¢–û–† –†–ï–ñ–ò–ú–ê -->
<div id="modeIndicator">
  <div class="mode-icon" id="modeIcon"></div>
  <span class="mode-text" id="modeText">–†–µ–∂–∏–º —Ä–∏—Å–æ–≤–∞–Ω–∏—è</span>
</div>

<!-- –ò–ù–î–ò–ö–ê–¢–û–† –ù–ê–í–ï–î–ï–ù–ò–Ø -->
<div id="hoverIndicator"></div>

<!-- –ö–ù–û–ü–ö–ê –ü–û–ö–ê–ó–ê/–°–ö–†–´–¢–ò–Ø -->
<button id="toggleSidebar" title="–ü–∞–Ω–µ–ª—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤">
  <span class="btn-icon">‚ö°</span>
</button>

<!-- –ö–û–ù–¢–ï–ô–ù–ï–† –ü–ê–ù–ï–õ–ï–ô -->
<div class="panels-container">
  <!-- –ü–ê–ù–ï–õ–¨ –ò–ù–°–¢–†–£–ú–ï–ù–¢–û–í -->
  <div id="toolsPanel">
    <div class="panel-indicator">üñåÔ∏è –ü–ê–ù–ï–õ–¨ –ò–ù–°–¢–†–£–ú–ï–ù–¢–û–í</div>
    
    <div class="section">
      <div class="section-title">–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã</div>
      <div class="button-grid">
        <button class="btn active" onclick="setTool('pen')" id="tool-pen">
          <span class="btn-icon">üñåÔ∏è</span>–ö–∏—Å—Ç—å
        </button>
        <button class="btn" onclick="setTool('line')" id="tool-line">
          <span class="btn-icon">üìè</span>–û—Ç—Ä–µ–∑–æ–∫
        </button>
        <button class="btn" onclick="setTool('rect')" id="tool-rect">
          <span class="btn-icon">‚¨ú</span>–ü—Ä—è–º–æ—É–≥.
        </button>
        <button class="btn" onclick="setTool('circle')" id="tool-circle">
          <span class="btn-icon">‚≠ï</span>–ö—Ä—É–≥
        </button>
        <button class="btn" onclick="setTool('triangle')" id="tool-triangle">
          <span class="btn-icon">üî∫</span>–¢—Ä–µ—É–≥.
        </button>
        <button class="btn" onclick="setTool('eraser')" id="tool-eraser">
          <span class="btn-icon">üßπ</span>–õ–∞—Å—Ç–∏–∫
        </button>
      </div>
    </div>

    <div class="section">
      <div class="section-title">–°—Ç–∏–ª—å</div>
      <div class="control-group">
        <input type="color" id="colorPicker" class="color-picker" value="#ff0000">
        
        <div class="slider-container">
          <div class="slider-label">
            <span>–¢–æ–ª—â–∏–Ω–∞</span>
            <span class="slider-value" id="widthValue">4px</span>
          </div>
          <input type="range" id="widthPicker" class="slider" min="1" max="30" value="4">
        </div>
        
        <div class="slider-container">
          <div class="slider-label">
            <span>–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å</span>
            <span class="slider-value" id="opacityValue">100%</span>
          </div>
          <input type="range" id="opacityPicker" class="slider" min="10" max="100" value="100">
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title">–¶–≤–µ—Ç–∞</div>
      <div class="color-palette" id="colorPalette">
        <div class="color-swatch" style="background: #ff0000;"></div>
        <div class="color-swatch" style="background: #ffff00;"></div>
        <div class="color-swatch" style="background: #00ff00;"></div>
        <div class="color-swatch" style="background: #0000ff;"></div>
        <div class="color-swatch" style="background: #ffffff;"></div>
      </div>
    </div>

    <div class="section">
      <div class="section-title">–ò—Å—Ç–æ—Ä–∏—è</div>
      <div class="button-row">
        <button class="btn" onclick="undo()">
          <span class="btn-icon">‚Ü∂</span>–ù–∞–∑–∞–¥
        </button>
        <button class="btn" onclick="redo()">
          <span class="btn-icon">‚Ü∑</span>–í–ø–µ—Ä—ë–¥
        </button>
      </div>
    </div>
  </div>

  <!-- –ü–ê–ù–ï–õ–¨ –ù–ê–°–¢–†–û–ï–ö -->
  <div id="settingsPanel">
    <div class="panel-indicator">‚öôÔ∏è –ü–ê–ù–ï–õ–¨ –ù–ê–°–¢–†–û–ï–ö</div>
    
    <div class="section">
      <div class="section-title">–ö–∞–º–µ—Ä–∞</div>
      <div class="button-row">
        <button class="btn" onclick="toggleCameraMirror()" id="mirrorBtn">
          <span class="btn-icon">üîÑ</span>–ó–µ—Ä–∫–∞–ª–æ
        </button>
        <button class="btn" onclick="toggleCamera()" id="cameraToggleBtn">
          <span class="btn-icon">üì∑</span>–í–∫–ª.
        </button>
      </div>
    </div>

    <div class="section">
      <div class="section-title">–§–æ–Ω</div>
      <div class="toggle-group">
        <span class="toggle-label">–¶–≤–µ—Ç–Ω–æ–π —Ñ–æ–Ω</span>
        <div class="toggle-btn" id="bgToggleBtn" onclick="toggleBackground()"></div>
      </div>
      <div id="colorControls" style="margin-top: 10px;">
        <div class="slider-label">–¶–≤–µ—Ç —Ñ–æ–Ω–∞</div>
        <input type="color" id="bgColorPicker" class="color-picker" value="#0b0b10">
      </div>
    </div>

    <div class="section">
      <div class="section-title">–≠–∫—Å–ø–æ—Ä—Ç</div>
      <div class="export-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
        <button class="btn export-btn" onclick="saveTransparent()">
          <span class="btn-icon">üñºÔ∏è</span>PNG –ø—Ä–æ–∑—Ä.
        </button>
        <button class="btn export-btn" onclick="saveWithBackground()">
          <span class="btn-icon">üèûÔ∏è</span>PNG+—Ñ–æ–Ω
        </button>
        <button class="btn export-btn" onclick="saveWithColorBackground()">
          <span class="btn-icon">üé®</span>PNG —Ü–≤–µ—Ç
        </button>
        <button class="btn export-btn" onclick="importBackground()">
          <span class="btn-icon">üìÅ</span>–ó–∞–≥—Ä. —Ñ–æ–Ω
        </button>
      </div>
    </div>

    <div class="section">
      <div class="section-title">–ù–∞–≤–∏–≥–∞—Ü–∏—è</div>
      <div class="button-row">
        <button class="btn" onclick="location.href='index.html'">
          <span class="btn-icon">üè†</span>–ì–ª–∞–≤–Ω–∞—è
        </button>
        <button class="btn" onclick="location.href='3D.html'">
          <span class="btn-icon">üî∫</span>3D
        </button>
      </div>
    </div>
  </div>
</div>

<!-- STATUS BAR -->
<div id="statusBar">
  <div class="status-item">
    <div class="status-dot recording"></div>
    <span>–ö–∞–º–µ—Ä–∞</span>
  </div>
  <div class="status-item">
    <span>üõ†Ô∏è <span id="currentTool">–ö–∏—Å—Ç—å</span></span>
  </div>
  <div class="status-item">
    <span>üìú <span id="historyCount">0</span></span>
  </div>
</div>

<script type="module">
import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8";

// ===== –°–û–°–¢–û–Ø–ù–ò–ï –ü–†–ò–õ–û–ñ–ï–ù–ò–Ø =====
const state = {
  tool: "pen",
  color: "#ff0000",
  width: 4,
  opacity: 1,
  actions: [],
  redo: [],
  current: null,
  backgroundImage: null
};

// ===== –°–û–°–¢–û–Ø–ù–ò–ï –ö–ê–ú–ï–†–´ =====
let isCameraEnabled = true;
let isCameraMirrored = false;
let isBackgroundEnabled = false;
let bgColor = "#0b0b10";

// ===== –°–û–°–¢–û–Ø–ù–ò–ï –†–ï–ñ–ò–ú–û–í =====
let currentMode = 'drawing';
let wasFist = false;
let fistToggleCooldown = 0;
let activePanel = null;

// ===== –≠–õ–ï–ú–ï–ù–¢–´ UI =====
const pinchCursor = document.getElementById("pinchCursor");
const toolsPanel = document.getElementById("toolsPanel");
const settingsPanel = document.getElementById("settingsPanel");
const toggleSidebar = document.getElementById("toggleSidebar");
const modeText = document.getElementById("modeText");
const modeIcon = document.getElementById("modeIcon");
const hoverIndicator = document.getElementById("hoverIndicator");
const currentToolElement = document.getElementById("currentTool");
const historyCountElement = document.getElementById("historyCount");
const colorPicker = document.getElementById("colorPicker");

// ===== –ö–ê–ú–ï–†–ê =====
const video = document.getElementById("camera");
let cameraInitialized = false;

async function initCamera() {
  try {
    video.srcObject = await navigator.mediaDevices.getUserMedia({ 
      video: { 
        width: { ideal: 1280 },
        height: { ideal: 720 },
        facingMode: "user" 
      } 
    });
    
    await new Promise((resolve) => {
      video.onloadedmetadata = () => {
        video.play().then(() => {
          cameraInitialized = true;
          resolve();
        }).catch(err => {
          console.warn('–ê–≤—Ç–æ–≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ:', err);
          showCameraPermissionPrompt();
          resolve();
        });
      };
    });
  } catch (error) {
    console.error("–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –∫–∞–º–µ—Ä–µ:", error);
    showCameraError();
  }
}

function showCameraPermissionPrompt() {
  const prompt = document.createElement('div');
  prompt.id = 'cameraPrompt';
  prompt.innerHTML = `
    <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); backdrop-filter: blur(12px); z-index: 10000; display: flex; align-items: center; justify-content: center;">
      <div style="background: var(--surface-elevated); padding: 40px; border-radius: 48px; max-width: 400px; text-align: center; border: 1px solid rgba(75,227,255,0.3); box-shadow: 0 30px 60px black;">
        <h3 style="margin-bottom: 16px; color: var(--accent-primary); font-size: 24px;">‚ú® –î–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ</h3>
        <p style="margin-bottom: 28px; color: var(--text-soft);">–†–∞–∑—Ä–µ—à–∏—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∫–∞–º–µ—Ä—ã –¥–ª—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è –∂–µ—Å—Ç–∞–º–∏</p>
        <button id="enableCameraBtn" style="background: var(--accent-primary); color: black; border: none; padding: 16px 32px; border-radius: 40px; font-weight: bold; font-size: 16px; cursor: pointer; box-shadow: 0 0 30px var(--accent-primary);">
          –í–∫–ª—é—á–∏—Ç—å –∫–∞–º–µ—Ä—É
        </button>
      </div>
    </div>
  `;
  document.body.appendChild(prompt);
  document.getElementById('enableCameraBtn').addEventListener('click', async () => {
    try {
      await video.play();
      prompt.remove();
      cameraInitialized = true;
    } catch (err) {
      console.error('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å –∫–∞–º–µ—Ä—É:', err);
    }
  });
}

function showCameraError() {
  const error = document.createElement('div');
  error.innerHTML = `
    <div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); backdrop-filter: blur(12px); z-index: 10000; display: flex; align-items: center; justify-content: center;">
      <div style="background: var(--surface-elevated); padding: 40px; border-radius: 48px; border: 1px solid #ff6b6b;">
        <h3 style="margin-bottom: 16px; color: #ff6b6b;">‚ö†Ô∏è –û—à–∏–±–∫–∞ –∫–∞–º–µ—Ä—ã</h3>
        <p style="margin-bottom: 28px;">–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –∫–∞–º–µ—Ä–µ</p>
        <button onclick="location.reload()" style="background: #ff6b6b; color: white; border: none; padding: 14px 32px; border-radius: 40px; font-weight: bold; cursor: pointer;">
          –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å
        </button>
      </div>
    </div>
  `;
  document.body.appendChild(error);
}

initCamera();

// ===== CANVAS =====
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

function initCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
  ctx.clearRect(0, 0, canvas.width, canvas.height);
}
initCanvas();

// ===== –§–£–ù–ö–¶–ò–Ø –í–´–ë–û–†–ê –¶–í–ï–¢–ê =====
window.selectColor = (color) => {
  state.color = color;
  colorPicker.value = color;
  
  document.querySelectorAll('.color-swatch').forEach(swatch => {
    swatch.classList.remove('active');
  });
  
  const activeSwatch = Array.from(document.querySelectorAll('.color-swatch')).find(
    swatch => swatch.getAttribute('data-color') === color
  );
  if (activeSwatch) {
    activeSwatch.classList.add('active');
  }
  
  if (state.tool !== 'eraser') {
    pinchCursor.style.background = `radial-gradient(circle at 30% 30%, rgba(${hexToRgb(state.color)}, 0.95), rgba(${hexToRgb(state.color)}, 0.8))`;
  }
  
  showHoverIndicator(`üé® –¶–≤–µ—Ç: ${color}`);
};

// ===== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø –¶–í–ï–¢–û–í–û–ô –ü–ê–õ–ò–¢–†–´ =====
function initColorPalette() {
  const swatches = document.querySelectorAll('.color-swatch');
  const colors = ['#ff0000', '#ffff00', '#00ff00', '#0000ff', '#ffffff'];
  
  swatches.forEach((swatch, index) => {
    swatch.setAttribute('data-color', colors[index]);
    swatch.style.pointerEvents = 'auto';
    swatch.style.cursor = 'pointer';
    
    swatch.addEventListener('click', (e) => {
      e.stopPropagation();
      const color = e.currentTarget.getAttribute('data-color');
      if (color) {
        selectColor(color);
        showClickFeedback(e.currentTarget);
      }
    });
  });
  
  if (swatches[0]) {
    swatches[0].classList.add('active');
  }
}

setTimeout(initColorPalette, 100);

// ===== –£–ü–†–ê–í–õ–ï–ù–ò–ï –†–ï–ñ–ò–ú–ê–ú–ò =====
function switchMode(mode) {
  if (mode === currentMode) return;
  
  currentMode = mode;
  
  if (mode === 'drawing') {
    modeText.textContent = '–†–µ–∂–∏–º —Ä–∏—Å–æ–≤–∞–Ω–∏—è';
    modeIcon.className = 'mode-icon drawing';
    pinchCursor.classList.remove('ui-mode');
  } else {
    modeText.textContent = '–†–µ–∂–∏–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è';
    modeIcon.className = 'mode-icon';
    pinchCursor.classList.add('ui-mode');
  }
  
  if (mode === 'ui' && drawing) {
    drawing = false;
    state.current = null;
  }
}

// ===== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ü–ê–ù–ï–õ–Ø–ú–ò =====
function togglePanelsWithFist() {
  if (!toolsPanel.classList.contains('visible') && !settingsPanel.classList.contains('visible')) {
    toolsPanel.classList.add('visible');
    settingsPanel.classList.remove('visible');
    activePanel = 'tools';
    switchMode('ui');
    showHoverIndicator('üñåÔ∏è –ü–∞–Ω–µ–ª—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –æ—Ç–∫—Ä—ã—Ç–∞');
  } 
  else if (toolsPanel.classList.contains('visible') && !settingsPanel.classList.contains('visible')) {
    toolsPanel.classList.remove('visible');
    settingsPanel.classList.add('visible');
    activePanel = 'settings';
    showHoverIndicator('‚öôÔ∏è –ü–∞–Ω–µ–ª—å –Ω–∞—Å—Ç—Ä–æ–µ–∫ –æ—Ç–∫—Ä—ã—Ç–∞');
  }
  else if (settingsPanel.classList.contains('visible')) {
    settingsPanel.classList.remove('visible');
    toolsPanel.classList.remove('visible');
    activePanel = null;
    switchMode('drawing');
    showHoverIndicator('üëä –ü–∞–Ω–µ–ª–∏ –∑–∞–∫—Ä—ã—Ç—ã');
  }
}

function handlePanelHover(point) {
  const element = document.elementFromPoint(point.x * window.innerWidth, point.y * window.innerHeight);
  
  if (toolsPanel.contains(element) && !toolsPanel.classList.contains('visible')) {
    toolsPanel.classList.add('visible');
    settingsPanel.classList.remove('visible');
    activePanel = 'tools';
    switchMode('ui');
    showHoverIndicator('üñåÔ∏è –ü–∞–Ω–µ–ª—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤');
  }
  else if (settingsPanel.contains(element) && !settingsPanel.classList.contains('visible')) {
    settingsPanel.classList.add('visible');
    toolsPanel.classList.remove('visible');
    activePanel = 'settings';
    switchMode('ui');
    showHoverIndicator('‚öôÔ∏è –ü–∞–Ω–µ–ª—å –Ω–∞—Å—Ç—Ä–æ–µ–∫');
  }
}

function showHoverIndicator(text) {
  hoverIndicator.textContent = text;
  hoverIndicator.style.display = 'block';
  setTimeout(() => {
    hoverIndicator.style.display = 'none';
  }, 2000);
}

// ===== –†–ê–°–ü–û–ó–ù–ê–í–ê–ù–ò–ï –ñ–ï–°–¢–û–í =====
const vision = await FilesetResolver.forVisionTasks(
  "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm"
);

const hand = await HandLandmarker.createFromOptions(vision, {
  baseOptions: { 
    modelAssetPath: "https://storage.googleapis.com/mediapipe-assets/hand_landmarker.task" 
  },
  runningMode: "VIDEO",
  numHands: 1
});

const PINCH_THRESHOLD = 0.08;
let drawing = false;
let lastPoint = null;
const SMOOTHING_FACTOR = 0.4;

function isFistGesture(landmarks) {
  if (!landmarks || landmarks.length < 21) return false;
  const lm = landmarks;
  if (!lm[0] || !lm[4] || !lm[8] || !lm[12] || !lm[16] || !lm[20]) return false;
  
  const wrist = lm[0];
  const thumbTip = lm[4];
  const indexTip = lm[8];
  const middleTip = lm[12];
  const ringTip = lm[16];
  const pinkyTip = lm[20];
  
  const maxFistDistance = 0.15;
  const thumbDistance = Math.hypot(thumbTip.x - wrist.x, thumbTip.y - wrist.y);
  const indexDistance = Math.hypot(indexTip.x - wrist.x, indexTip.y - wrist.y);
  const middleDistance = Math.hypot(middleTip.x - wrist.x, middleTip.y - wrist.y);
  const ringDistance = Math.hypot(ringTip.x - wrist.x, ringTip.y - wrist.y);
  const pinkyDistance = Math.hypot(pinkyTip.x - wrist.x, pinkyTip.y - wrist.y);
  
  return thumbDistance < maxFistDistance &&
         indexDistance < maxFistDistance &&
         middleDistance < maxFistDistance &&
         ringDistance < maxFistDistance &&
         pinkyDistance < maxFistDistance;
}

// ===== –û–°–ù–û–í–ù–û–ô –û–ë–†–ê–ë–û–¢–ß–ò–ö –†–£–ö–ò =====
function handleHand(landmarks) {
  if (!landmarks || landmarks.length < 21) {
    pinchCursor.style.display = 'none';
    return;
  }
  
  pinchCursor.style.display = 'block';
  
  const thumb = landmarks[4];
  const index = landmarks[8];
  if (!thumb || !index) return;
  
  const pinchDistance = Math.hypot(thumb.x - index.x, thumb.y - index.y);
  const isPinching = pinchDistance < PINCH_THRESHOLD;
  
  let isFistNow = false;
  try {
    isFistNow = isFistGesture(landmarks);
  } catch (error) {
    isFistNow = false;
  }
  
  if (isFistNow && !wasFist && fistToggleCooldown <= 0) {
    togglePanelsWithFist();
    wasFist = true;
    fistToggleCooldown = 30;
    
    pinchCursor.classList.add('cursor-fist');
    setTimeout(() => {
      pinchCursor.classList.remove('cursor-fist');
    }, 500);
  } else if (!isFistNow && wasFist) {
    wasFist = false;
  }
  
  if (fistToggleCooldown > 0) fistToggleCooldown--;
  
  const rawPoint = {
    x: (thumb.x + index.x) / 2,
    y: (thumb.y + index.y) / 2
  };
  
  if (lastPoint) {
    rawPoint.x = lastPoint.x * (1 - SMOOTHING_FACTOR) + rawPoint.x * SMOOTHING_FACTOR;
    rawPoint.y = lastPoint.y * (1 - SMOOTHING_FACTOR) + rawPoint.y * SMOOTHING_FACTOR;
  }
  lastPoint = { x: rawPoint.x, y: rawPoint.y };
  
  updateCursor(rawPoint, isPinching);
  
  if (isFistNow) return;
  
  handlePanelHover(rawPoint);
  
  if (currentMode === 'ui') {
    handleUIClickDetection(rawPoint, isPinching);
  } else {
    handleDrawing(rawPoint, isPinching);
  }
}

function updateCursor(point, isPinching) {
  pinchCursor.style.left = point.x * window.innerWidth + "px";
  pinchCursor.style.top = point.y * window.innerHeight + "px";
  pinchCursor.classList.toggle("active", isPinching);
}

// ===== –†–ò–°–û–í–ê–ù–ò–ï =====
function handleDrawing(point, isPinching) {
  if (isPinching && !drawing) {
    drawing = true;
    if (state.tool === "pen") {
      state.current = {
        type: "pen",
        tool: state.tool,
        color: state.color,
        width: state.width,
        opacity: state.opacity,
        points: [{ x: point.x, y: point.y }]
      };
    } else {
      state.current = {
        type: state.tool,
        tool: state.tool,
        color: state.tool === 'eraser' ? null : state.color,
        width: state.width,
        opacity: state.opacity,
        start: { x: point.x, y: point.y },
        end: { x: point.x, y: point.y }
      };
    }
    return;
  }
  
  if (isPinching && drawing && state.current) {
    if (state.current.type === "pen") {
      state.current.points.push({ x: point.x, y: point.y });
    } else {
      state.current.end = { x: point.x, y: point.y };
    }
  }
  
  if (!isPinching && drawing && state.current) {
    drawing = false;
    const hasSize = checkDrawingSize(state.current);
    if (hasSize) {
      const actionCopy = JSON.parse(JSON.stringify(state.current));
      state.actions.push(actionCopy);
      state.redo = [];
    }
    state.current = null;
  }
}

function checkDrawingSize(action) {
  if (action.type === "pen") return action.points.length > 2;
  else {
    const dx = action.end.x - action.start.x;
    const dy = action.end.y - action.start.y;
    return Math.hypot(dx, dy) > 0.02;
  }
}

// ===== –§–£–ù–ö–¶–ò–ò –†–ò–°–û–í–ê–ù–ò–Ø =====
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (state.backgroundImage) {
    ctx.drawImage(state.backgroundImage, 0, 0, canvas.width, canvas.height);
  }
  state.actions.forEach(action => drawAction(action));
  if (state.current) {
    drawAction(state.current, true);
  }
  historyCountElement.textContent = `${state.actions.length}`;
}

function drawAction(action, isPreview = false) {
  if (!action) return;
  ctx.save();
  const color = action.tool === 'eraser' ? 'rgba(0,0,0,0)' : action.color;
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = action.width;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  ctx.globalAlpha = isPreview ? 0.7 : action.opacity;
  if (action.tool === 'eraser') ctx.globalCompositeOperation = 'destination-out';
  
  if (action.type === "pen") drawPen(action);
  else if (action.type === "line") drawLine(action);
  else if (action.type === "rect") drawRect(action);
  else if (action.type === "circle") drawCircle(action);
  else if (action.type === "triangle") drawTriangle(action);
  
  ctx.restore();
}

function drawPen(action) {
  if (action.points.length < 2) return;
  ctx.beginPath();
  ctx.moveTo(action.points[0].x * canvas.width, action.points[0].y * canvas.height);
  for (let i = 1; i < action.points.length; i++) {
    const prev = action.points[i - 1];
    const curr = action.points[i];
    const midX = (prev.x + curr.x) / 2 * canvas.width;
    const midY = (prev.y + curr.y) / 2 * canvas.height;
    ctx.quadraticCurveTo(prev.x * canvas.width, prev.y * canvas.height, midX, midY);
  }
  ctx.stroke();
}

function drawLine(action) {
  ctx.beginPath();
  ctx.moveTo(action.start.x * canvas.width, action.start.y * canvas.height);
  ctx.lineTo(action.end.x * canvas.width, action.end.y * canvas.height);
  ctx.stroke();
}

function drawRect(action) {
  const x = Math.min(action.start.x, action.end.x) * canvas.width;
  const y = Math.min(action.start.y, action.end.y) * canvas.height;
  const w = Math.abs(action.end.x - action.start.x) * canvas.width;
  const h = Math.abs(action.end.y - action.start.y) * canvas.height;
  ctx.beginPath();
  ctx.rect(x, y, w, h);
  ctx.stroke();
}

function drawCircle(action) {
  const cx = (action.start.x + action.end.x) / 2 * canvas.width;
  const cy = (action.start.y + action.end.y) / 2 * canvas.height;
  const radius = Math.hypot(action.end.x - action.start.x, action.end.y - action.start.y) * canvas.width / 2;
  ctx.beginPath();
  ctx.arc(cx, cy, radius, 0, Math.PI * 2);
  ctx.stroke();
}

function drawTriangle(action) {
  const x1 = action.start.x * canvas.width;
  const y1 = action.start.y * canvas.height;
  const x2 = action.end.x * canvas.width;
  const y2 = action.end.y * canvas.height;
  ctx.beginPath();
  ctx.moveTo(x1, y2);
  ctx.lineTo((x1 + x2) / 2, y1);
  ctx.lineTo(x2, y2);
  ctx.closePath();
  ctx.stroke();
}

// ===== UI –ö–õ–ò–ö–ò =====
let isPotentialClick = false;
let potentialClickElement = null;
let clickStartTime = 0;
const CLICK_TIME_THRESHOLD = 500;

function getElementAtPoint(x, y) {
  const screenX = x * window.innerWidth;
  const screenY = y * window.innerHeight;
  return document.elementFromPoint(screenX, screenY);
}

function isClickableElement(element) {
  if (!element) return false;
  const clickableTags = ['BUTTON', 'A', 'INPUT'];
  const clickableClasses = ['btn', 'color-picker', 'slider', 'toggle-btn', 'panel-indicator', 'color-swatch'];
  
  if (clickableTags.includes(element.tagName)) return true;
  for (const className of clickableClasses) {
    if (element.classList.contains(className)) return true;
  }
  return false;
}

function highlightElement(element, highlight = true) {
  if (!element) return;
  let clickableElement = element;
  if (!isClickableElement(element)) {
    clickableElement = element.closest('.btn, .color-picker, .slider, .toggle-btn, .panel-indicator, .color-swatch');
  }
  if (!clickableElement) return;
  
  if (highlight) {
    clickableElement.style.outline = '3px solid var(--accent-primary)';
    clickableElement.style.outlineOffset = '4px';
    clickableElement.style.boxShadow = '0 0 30px var(--accent-primary)';
  } else {
    clickableElement.style.outline = '';
    clickableElement.style.outlineOffset = '';
    clickableElement.style.boxShadow = '';
  }
}

function handleElementClick(element) {
  if (!element) return;
  
  let clickableElement = element;
  if (!isClickableElement(element)) {
    clickableElement = element.closest('.btn, .color-picker, .slider, .toggle-btn, .panel-indicator, .color-swatch');
  }
  if (!clickableElement) return;
  
  if (clickableElement.classList.contains('color-swatch')) {
    const color = clickableElement.getAttribute('data-color');
    if (color) {
      selectColor(color);
      showClickFeedback(clickableElement);
    }
    return;
  }
  
  if (clickableElement.tagName === 'BUTTON') {
    clickableElement.click();
    const originalBackground = clickableElement.style.background;
    clickableElement.style.background = 'rgba(75,227,255,0.3)';
    setTimeout(() => {
      clickableElement.style.background = originalBackground;
    }, 200);
  } else if (clickableElement.type === 'range') {
    const rect = clickableElement.getBoundingClientRect();
    const x = (lastPoint.x * window.innerWidth - rect.left) / rect.width;
    const value = Math.min(Math.max(x, 0), 1);
    const min = parseFloat(clickableElement.min) || 0;
    const max = parseFloat(clickableElement.max) || 100;
    const newValue = min + value * (max - min);
    clickableElement.value = newValue;
    clickableElement.dispatchEvent(new Event('input'));
    clickableElement.dispatchEvent(new Event('change'));
  } else if (clickableElement.type === 'color') {
    clickableElement.click();
  }
  
  showClickFeedback(clickableElement);
}

function showClickFeedback(element) {
  const rect = element.getBoundingClientRect();
  const feedback = document.createElement('div');
  feedback.className = 'feedback-ripple';
  feedback.style.left = rect.left + rect.width / 2 + 'px';
  feedback.style.top = rect.top + rect.height / 2 + 'px';
  document.body.appendChild(feedback);
  setTimeout(() => feedback.remove(), 400);
}

function handleUIClickDetection(point, isPinching) {
  const element = getElementAtPoint(point.x, point.y);
  
  if (element && element.classList && element.classList.contains('color-swatch')) {
    if (isPinching && !isPotentialClick) {
      isPotentialClick = true;
      clickStartTime = Date.now();
    }
    
    if (!isPinching && isPotentialClick) {
      const clickDuration = Date.now() - clickStartTime;
      if (clickDuration < CLICK_TIME_THRESHOLD) {
        const color = element.getAttribute('data-color');
        if (color) {
          selectColor(color);
          showClickFeedback(element);
        }
      }
      isPotentialClick = false;
      clickStartTime = 0;
    }
    return;
  }
  
  if (isClickableElement(element) && !element?.classList?.contains('color-swatch')) {
    if (potentialClickElement !== element) {
      if (potentialClickElement) highlightElement(potentialClickElement, false);
      potentialClickElement = element;
      highlightElement(element, true);
    }
    
    if (isPinching && !isPotentialClick) {
      isPotentialClick = true;
      clickStartTime = Date.now();
    }
    
    if (!isPinching && isPotentialClick) {
      const clickDuration = Date.now() - clickStartTime;
      if (clickDuration < CLICK_TIME_THRESHOLD) {
        handleElementClick(element);
      }
      isPotentialClick = false;
      clickStartTime = 0;
    }
  } else {
    if (potentialClickElement) {
      highlightElement(potentialClickElement, false);
      potentialClickElement = null;
    }
    if (isPinching && isPotentialClick) {
      isPotentialClick = false;
      clickStartTime = 0;
    }
  }
  
  if (isPinching && isPotentialClick) {
    const clickDuration = Date.now() - clickStartTime;
    if (clickDuration > CLICK_TIME_THRESHOLD) isPotentialClick = false;
  }
}

// ===== –£–ü–†–ê–í–õ–ï–ù–ò–ï –ò–ù–°–¢–†–£–ú–ï–ù–¢–ê–ú–ò =====
window.setTool = (tool) => {
  state.tool = tool;
  currentToolElement.textContent = getToolName(tool);
  
  document.querySelectorAll('[id^="tool-"]').forEach(btn => {
    btn.classList.remove('active');
  });
  document.getElementById(`tool-${tool}`).classList.add('active');
  
  const cursor = document.getElementById('pinchCursor');
  cursor.classList.remove('cursor-eraser', 'cursor-fist');
  
  if (tool === 'eraser') {
    cursor.style.background = 'radial-gradient(circle at 30% 30%, #ffffff, #e0e0e0)';
    cursor.classList.add('cursor-eraser');
  } else {
    cursor.style.background = `radial-gradient(circle at 30% 30%, rgba(${hexToRgb(state.color)}, 0.95), rgba(${hexToRgb(state.color)}, 0.8))`;
  }
};

function getToolName(tool) {
  const names = { pen: '–ö–∏—Å—Ç—å', line: '–û—Ç—Ä–µ–∑–æ–∫', rect: '–ü—Ä—è–º–æ—É–≥.', circle: '–ö—Ä—É–≥', triangle: '–¢—Ä–µ—É–≥.', eraser: '–õ–∞—Å—Ç–∏–∫' };
  return names[tool] || tool;
}

// ===== COLOR & STYLE CONTROLS =====
colorPicker.addEventListener('input', (e) => {
  state.color = e.target.value;
  
  document.querySelectorAll('.color-swatch').forEach(swatch => {
    swatch.classList.remove('active');
  });
  
  if (state.tool !== 'eraser') {
    pinchCursor.style.background = `radial-gradient(circle at 30% 30%, rgba(${hexToRgb(state.color)}, 0.95), rgba(${hexToRgb(state.color)}, 0.8))`;
  }
});

document.getElementById('widthPicker').addEventListener('input', (e) => {
  state.width = +e.target.value;
  document.getElementById('widthValue').textContent = `${state.width}px`;
});

document.getElementById('opacityPicker').addEventListener('input', (e) => {
  state.opacity = +e.target.value / 100;
  document.getElementById('opacityValue').textContent = `${e.target.value}%`;
});

// ===== CAMERA CONTROLS =====
window.toggleCameraMirror = () => {
  isCameraMirrored = !isCameraMirrored;
  video.classList.toggle('mirrored', isCameraMirrored);
  document.getElementById('mirrorBtn').innerHTML = 
    isCameraMirrored 
      ? '<span class="btn-icon">üîÅ</span>–û–±—ã—á–Ω—ã–π'
      : '<span class="btn-icon">üîÑ</span>–ó–µ—Ä–∫–∞–ª–æ';
};

window.toggleCamera = () => {
  isCameraEnabled = !isCameraEnabled;
  if (isCameraEnabled) {
    video.classList.remove('hidden');
    video.play();
    document.getElementById('cameraToggleBtn').innerHTML = '<span class="btn-icon">üì∑</span>–í—ã–∫–ª.';
  } else {
    video.classList.add('hidden');
    video.pause();
    document.getElementById('cameraToggleBtn').innerHTML = '<span class="btn-icon">üì∑</span>–í–∫–ª.';
  }
};

window.toggleBackground = () => {
  const toggleBtn = document.getElementById('bgToggleBtn');
  isBackgroundEnabled = !isBackgroundEnabled;
  toggleBtn.classList.toggle('active', isBackgroundEnabled);
  const bgOverlay = document.getElementById('bgColorOverlay');
  if (isBackgroundEnabled) {
    bgOverlay.classList.add('visible');
    bgOverlay.style.backgroundColor = bgColor;
  } else {
    bgOverlay.classList.remove('visible');
  }
};

document.getElementById('bgColorPicker').addEventListener('input', (e) => {
  bgColor = e.target.value;
  const bgOverlay = document.getElementById('bgColorOverlay');
  if (isBackgroundEnabled) {
    bgOverlay.style.backgroundColor = bgColor;
  }
});

// ===== HISTORY =====
window.undo = () => { if (state.actions.length > 0) state.redo.push(state.actions.pop()); };
window.redo = () => { if (state.redo.length > 0) state.actions.push(state.redo.pop()); };

// ===== EXPORT =====
window.saveTransparent = () => {
  const exportCanvas = document.createElement("canvas");
  exportCanvas.width = canvas.width;
  exportCanvas.height = canvas.height;
  const exportCtx = exportCanvas.getContext("2d");
  state.actions.forEach(action => drawActionOnCanvas(action, exportCtx, exportCanvas));
  downloadImage(exportCanvas, "drawing-transparent.png");
};

window.saveWithBackground = () => {
  const exportCanvas = document.createElement("canvas");
  exportCanvas.width = canvas.width;
  exportCanvas.height = canvas.height;
  const exportCtx = exportCanvas.getContext("2d");
  
  if (isCameraEnabled && !isBackgroundEnabled && !state.backgroundImage) {
    exportCtx.drawImage(video, 0, 0, exportCanvas.width, exportCanvas.height);
  } else if (isBackgroundEnabled) {
    exportCtx.fillStyle = bgColor;
    exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
  } else if (state.backgroundImage) {
    exportCtx.drawImage(state.backgroundImage, 0, 0, exportCanvas.width, exportCanvas.height);
  } else {
    exportCtx.fillStyle = "#000000";
    exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
  }
  
  state.actions.forEach(action => drawActionOnCanvas(action, exportCtx, exportCanvas));
  downloadImage(exportCanvas, "drawing-with-background.png");
};

window.saveWithColorBackground = () => {
  const exportCanvas = document.createElement("canvas");
  exportCanvas.width = canvas.width;
  exportCanvas.height = canvas.height;
  const exportCtx = exportCanvas.getContext("2d");
  exportCtx.fillStyle = bgColor;
  exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
  state.actions.forEach(action => drawActionOnCanvas(action, exportCtx, exportCanvas));
  const colorName = bgColor.replace('#', '');
  downloadImage(exportCanvas, `drawing-${colorName}.png`);
};

function drawActionOnCanvas(action, context, targetCanvas) {
  const originalCanvas = canvas;
  const originalCtx = ctx;
  canvas = targetCanvas;
  ctx = context;
  drawAction(action);
  canvas = originalCanvas;
  ctx = originalCtx;
}

function downloadImage(canvas, filename) {
  const link = document.createElement("a");
  link.download = filename;
  link.href = canvas.toDataURL("image/png");
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}

window.importBackground = () => {
  const input = document.createElement("input");
  input.type = "file";
  input.accept = "image/*";
  input.onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (event) => {
      const img = new Image();
      img.onload = () => {
        state.backgroundImage = img;
        isCameraEnabled = false;
        isBackgroundEnabled = false;
        video.classList.add('hidden');
        document.getElementById('bgToggleBtn').classList.remove('active');
        document.getElementById('cameraToggleBtn').innerHTML = '<span class="btn-icon">üì∑</span>–í–∫–ª.';
      };
      img.src = event.target.result;
    };
    reader.readAsDataURL(file);
  };
  input.click();
};

// ===== UTILITY =====
function hexToRgb(hex) {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '255, 0, 0';
}

// ===== RESIZE =====
function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  draw();
}
window.addEventListener("resize", resize);
resize();

// ===== ANIMATION LOOP =====
function loop() {
  if (video.readyState >= 2) {
    const results = hand.detectForVideo(video, performance.now());
    if (results.landmarks && results.landmarks.length > 0) {
      handleHand(results.landmarks[0]);
    }
  }
  draw();
  requestAnimationFrame(loop);
}
loop();

// ===== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø =====
setTool('pen');
switchMode('drawing');
</script>
</body>
</html>